import requests
import time
import json
import threading
from concurrent.futures import ThreadPoolExecutor

# Test payloads with various vulnerabilities
test_payloads = [
    # Legitimate requests
    {
        "name": "legitimate_get",
        "method": "GET",
        "url": "http://127.0.0.1:8001/test",
        "headers": {"User-Agent": "Mozilla/5.0"},
        "data": None,
        "expected_blocked": False
    },
    {
        "name": "legitimate_post",
        "method": "POST",
        "url": "http://127.0.0.1:8001/test",
        "headers": {"Content-Type": "application/json"},
        "data": json.dumps({"user": "test", "password": "123456"}),
        "expected_blocked": False
    },

    # SQL Injection attempts
    {
        "name": "sql_injection_1",
        "method": "POST",
        "url": "http://127.0.0.1:8001/test",
        "headers": {"Content-Type": "application/x-www-form-urlencoded"},
        "data": "username=admin' OR '1'='1&password=anything",
        "expected_blocked": True
    },
    {
        "name": "sql_injection_2",
        "method": "GET",
        "url": "http://127.0.0.1:8001/test?user=admin'; DROP TABLE users;--",
        "headers": {},
        "data": None,
        "expected_blocked": True
    },

    # XSS attempts
    {
        "name": "xss_script",
        "method": "POST",
        "url": "http://127.0.0.1:8001/test",
        "headers": {"Content-Type": "application/json"},
        "data": json.dumps({"comment": "<script>alert('xss')</script>"}),
        "expected_blocked": True
    },
    {
        "name": "xss_img",
        "method": "GET",
        "url": "http://127.0.0.1:8001/test?search=<img src=x onerror=alert(1)>",
        "headers": {},
        "data": None,
        "expected_blocked": True
    },

    # Path traversal
    {
        "name": "path_traversal",
        "method": "GET",
        "url": "http://127.0.0.1:8001/../../../etc/passwd",
        "headers": {},
        "data": None,
        "expected_blocked": True
    },

    # Command injection
    {
        "name": "command_injection",
        "method": "POST",
        "url": "http://127.0.0.1:8001/test",
        "headers": {"Content-Type": "application/x-www-form-urlencoded"},
        "data": "cmd=ls; rm -rf /",
        "expected_blocked": True
    },

    # Large payload (potential DoS)
    {
        "name": "large_payload",
        "method": "POST",
        "url": "http://127.0.0.1:8001/test",
        "headers": {"Content-Type": "application/json"},
        "data": json.dumps({"data": "A" * 2000000}),  # 2MB payload
        "expected_blocked": True
    },

    # Invalid HTTP method
    {
        "name": "invalid_method",
        "method": "INVALID",
        "url": "http://127.0.0.1:8001/test",
        "headers": {},
        "data": None,
        "expected_blocked": True
    },

    # Malformed headers
    {
        "name": "malformed_headers",
        "method": "GET",
        "url": "http://127.0.0.1:8001/test",
        "headers": {"X-Test": "\x00\x01\x02"},
        "data": None,
        "expected_blocked": True
    }
]

def send_request(payload, request_id):
    """Send a single request and return the result"""
    try:
        response = requests.request(
            method=payload["method"],
            url=payload["url"],
            headers=payload["headers"],
            data=payload["data"],
            timeout=10
        )

        result = {
            "request_id": request_id,
            "name": payload["name"],
            "method": payload["method"],
            "url": payload["url"],
            "status_code": response.status_code,
            "expected_blocked": payload["expected_blocked"],
            "actual_blocked": response.status_code not in [200, 201, 202],
            "response_time": response.elapsed.total_seconds(),
            "content_length": len(response.content)
        }

        # Print result
        status = "BLOCKED" if result["actual_blocked"] else "ALLOWED"
        expected = "BLOCKED" if payload["expected_blocked"] else "ALLOWED"
        match = "✓" if result["actual_blocked"] == payload["expected_blocked"] else "✗"

        print(f"[{request_id}] {payload['name']}: {status} (expected {expected}) {match} - {response.status_code} - {result['response_time']:.3f}s")

        return result

    except requests.exceptions.RequestException as e:
        print(f"[{request_id}] {payload['name']}: ERROR - {str(e)}")
        return {
            "request_id": request_id,
            "name": payload["name"],
            "error": str(e)
        }

def run_continuous_test(duration_seconds=60, concurrent_requests=5):
    """Run continuous requests for a specified duration"""
    print(f"Starting continuous vulnerability test for {duration_seconds} seconds with {concurrent_requests} concurrent requests...")
    print("=" * 80)

    start_time = time.time()
    request_count = 0
    results = []

    with ThreadPoolExecutor(max_workers=concurrent_requests) as executor:
        while time.time() - start_time < duration_seconds:
            # Submit requests for all test payloads
            futures = []
            for i, payload in enumerate(test_payloads):
                request_id = f"{request_count:03d}-{i}"
                future = executor.submit(send_request, payload, request_id)
                futures.append(future)
                request_count += 1

            # Wait for all requests in this batch to complete
            for future in futures:
                result = future.result()
                if result:
                    results.append(result)

            # Small delay between batches
            time.sleep(0.1)

    # Summary
    print("\n" + "=" * 80)
    print("TEST SUMMARY")
    print("=" * 80)

    total_requests = len(results)
    successful_requests = len([r for r in results if "error" not in r])
    blocked_requests = len([r for r in results if r.get("actual_blocked", False)])
    allowed_requests = len([r for r in results if not r.get("actual_blocked", True) and "error" not in r])

    print(f"Total requests sent: {total_requests}")
    print(f"Successful requests: {successful_requests}")
    print(f"Blocked requests: {blocked_requests}")
    print(f"Allowed requests: {allowed_requests}")

    # Check expected vs actual
    correct_predictions = 0
    for result in results:
        if "expected_blocked" in result and result.get("actual_blocked") == result["expected_blocked"]:
            correct_predictions += 1

    accuracy = (correct_predictions / len(results)) * 100 if results else 0
    print(".1f")

    return results

if __name__ == "__main__":
    # Run the test for 30 seconds with 3 concurrent threads
    results = run_continuous_test(duration_seconds=30, concurrent_requests=3)